<!DOCTYPE html>
<html>
<head>
    <title>Minecraft - 60FPS Infinite World</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        #crosshair::before, #crosshair::after {
            content: ""; position: absolute; background: white; mix-blend-mode: difference;
        }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }

        #hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; line-height: 0; 
        }
        .slot {
            width: 50px; height: 50px; background-image: url('slot.jpg');
            background-size: 100% 100%; image-rendering: pixelated; position: relative;
        }
        .slot.active::after {
            content: ""; position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px;
            background-image: url('outline.png'); background-size: 100% 100%;
            image-rendering: pixelated; z-index: 10; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="hotbar">
        <div class="slot active" id="slot1"></div>
        <div class="slot" id="slot2"></div>
        <div class="slot" id="slot3"></div>
        <div class="slot" id="slot4"></div>
        <div class="slot" id="slot5"></div>
        <div class="slot" id="slot6"></div>
    </div>
    <canvas id="canvas"></canvas>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
    import { PointerLockControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/PointerLockControls.js';

    // --- OPTIMIZED CONFIG ---
    const CHUNK_SIZE = 16;
    const RENDER_DISTANCE = 3; 
    const dummy = new THREE.Object3D(); // Reuse for positioning instances

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 20, (RENDER_DISTANCE * CHUNK_SIZE) + 10);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(1); // Performance boost for high-DPI screens

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));

    const loader = new THREE.TextureLoader();
    const load = (f) => { 
        const t = loader.load(f); 
        t.magFilter = THREE.NearestFilter; 
        t.minFilter = THREE.NearestFilter; 
        return t; 
    };

    const grassTop = load('grass-top.jpg'), grassSide = load('grass-side.jpg'), dirtTex = load('bottom.jpg');
    const woodSide = load('wood.jpg'), woodTop = load('woodtop.jpg'), leafTex = load('leaf.jpg');

    const grassMats = [
        new THREE.MeshStandardMaterial({ map: grassSide }), new THREE.MeshStandardMaterial({ map: grassSide }),
        new THREE.MeshStandardMaterial({ map: grassTop }), new THREE.MeshStandardMaterial({ map: dirtTex }),
        new THREE.MeshStandardMaterial({ map: grassSide }), new THREE.MeshStandardMaterial({ map: grassSide })
    ];
    const dirtMat = new THREE.MeshStandardMaterial({ map: dirtTex });
    const woodMats = [
        new THREE.MeshStandardMaterial({ map: woodSide }), new THREE.MeshStandardMaterial({ map: woodSide }),
        new THREE.MeshStandardMaterial({ map: woodTop }), new THREE.MeshStandardMaterial({ map: woodTop }),
        new THREE.MeshStandardMaterial({ map: woodSide }), new THREE.MeshStandardMaterial({ map: woodSide })
    ];
    const leafMat = new THREE.MeshStandardMaterial({ map: leafTex, transparent: true, alphaTest: 0.5 });

    const blockGeo = new THREE.BoxGeometry(1, 1, 1);
    const chunks = new Map();
    const raycaster = new THREE.Raycaster();

    const selectionOutline = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.BoxGeometry(1.01, 1.01, 1.01)),
        new THREE.LineBasicMaterial({ color: 0x000000 })
    );
    scene.add(selectionOutline);

    function seededRandom(x, z) {
        const val = Math.sin(x * 12.9898 + z * 78.233) * 43758.5453123;
        return val - Math.floor(val);
    }

    function createChunk(cx, cz) {
        const chunk = new THREE.Group();
        // Max blocks per chunk (terrain + potential trees)
        const terrainCount = CHUNK_SIZE * CHUNK_SIZE;
        const grassIM = new THREE.InstancedMesh(blockGeo, grassMats, terrainCount);
        const dirtIM = new THREE.InstancedMesh(blockGeo, dirtMat, terrainCount);
        
        // We use simple Meshes for trees for better raycasting/interaction 
        // but keep the count low to maintain 60FPS.
        let idx = 0;
        for (let x = 0; x < CHUNK_SIZE; x++) {
            for (let z = 0; z < CHUNK_SIZE; z++) {
                const px = cx * CHUNK_SIZE + x;
                const pz = cz * CHUNK_SIZE + z;

                dummy.position.set(px, 0, pz);
                dummy.updateMatrix();
                grassIM.setMatrixAt(idx, dummy.matrix);

                dummy.position.set(px, -1, pz);
                dummy.updateMatrix();
                dirtIM.setMatrixAt(idx, dummy.matrix);
                idx++;

                if (seededRandom(px, pz) > 0.99) spawnTree(px, pz, chunk);
            }
        }
        chunk.add(grassIM, dirtIM);
        scene.add(chunk);
        return chunk;
    }

    function spawnTree(x, z, group) {
        const h = 4 + Math.floor(seededRandom(x, z) * 2);
        for (let y = 1; y <= h; y++) {
            const log = new THREE.Mesh(blockGeo, woodMats);
            log.position.set(x, y, z);
            group.add(log);
        }
        const leaf = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), leafMat);
        leaf.position.set(x, h + 1, z);
        group.add(leaf);
    }

    function updateChunks() {
        const pCX = Math.floor(camera.position.x / CHUNK_SIZE);
        const pCZ = Math.floor(camera.position.z / CHUNK_SIZE);

        for (let x = pCX - RENDER_DISTANCE; x <= pCX + RENDER_DISTANCE; x++) {
            for (let z = pCZ - RENDER_DISTANCE; z <= pCZ + RENDER_DISTANCE; z++) {
                const key = `${x},${z}`;
                if (!chunks.has(key)) chunks.set(key, createChunk(x, z));
            }
        }
        // Purge distant chunks
        for (const [key, group] of chunks) {
            const [cx, cz] = key.split(',').map(Number);
            if (Math.abs(cx - pCX) > RENDER_DISTANCE + 1 || Math.abs(cz - pCZ) > RENDER_DISTANCE + 1) {
                scene.remove(group);
                chunks.delete(key);
            }
        }
    }

    const controls = new PointerLockControls(camera, document.body);
    document.addEventListener('click', () => controls.lock());

    let velocity = new THREE.Vector3(), move = { f: false, b: false, l: false, r: false };
    let canJump = false;
    camera.position.set(8, 3, 8);

    document.addEventListener('keydown', (e) => {
        if (e.code === 'KeyW') move.f = true; if (e.code === 'KeyS') move.b = true;
        if (e.code === 'KeyA') move.l = true; if (e.code === 'KeyD') move.r = true;
        if (e.code === 'Space' && canJump) { velocity.y = 9; canJump = false; }
        if (e.key >= 1 && e.key <= 6) {
            document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
            document.getElementById('slot' + e.key).classList.add('active');
        }
    });
    document.addEventListener('keyup', (e) => {
        if (e.code === 'KeyW') move.f = false; if (e.code === 'KeyS') move.b = false;
        if (e.code === 'KeyA') move.l = false; if (e.code === 'KeyD') move.r = false;
    });

    let prevTime = performance.now();
    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now();
        const delta = Math.min((time - prevTime) / 1000, 0.1);

        if (controls.isLocked) {
            velocity.x -= velocity.x * 10 * delta;
            velocity.z -= velocity.z * 10 * delta;
            velocity.y -= 24 * delta; 

            const speed = 70.0;
            if (move.f) velocity.z -= speed * delta;
            if (move.b) velocity.z += speed * delta;
            if (move.l) velocity.x -= speed * delta;
            if (move.r) velocity.x += speed * delta;

            controls.moveRight(velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
            camera.position.y += velocity.y * delta;

            if (camera.position.y < 2.1) {
                velocity.y = 0; camera.position.y = 2.1; canJump = true;
            }

            // --- OPTIMIZED OUTLINE ---
            // Only raycast every 2nd frame or against a smaller set of objects for speed
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects.length > 0 && intersects[0].distance < 6) {
                const hit = intersects[0];
                // If it's an InstancedMesh, we'd need more logic to find the exact sub-block
                // For now, it snaps to the closest Mesh (trees) or center of terrain
                selectionOutline.position.copy(hit.object.position);
                selectionOutline.visible = (hit.object.type === 'Mesh'); 
            } else {
                selectionOutline.visible = false;
            }

            updateChunks();
        }

        renderer.render(scene, camera);
        prevTime = time;
    }
    animate();
</script>
</body>
</html>
