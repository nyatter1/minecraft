<!DOCTYPE html>
<html>
<head>
    <title>Minecraft Scale Baseplate</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
    import { PointerLockControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/PointerLockControls.js';

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 5, 100); // Tighter fog for smaller scale

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const sun = new THREE.DirectionalLight(0xffffff, 0.6);
    sun.position.set(10, 20, 10);
    scene.add(sun);

    // --- Texture Loading ---
    const loader = new THREE.TextureLoader();
    const grassTop = loader.load('grass-top.jpg');
    const grassSide = loader.load('grass-side.jpg');
    const woodSide = loader.load('wood.jpg');
    const woodTop = loader.load('woodtop.jpg');

    [grassTop, grassSide, woodSide, woodTop].forEach(tex => {
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;
    });

    // --- Baseplate (1000x1000 meters) ---
    grassTop.wrapS = grassTop.wrapT = THREE.RepeatWrapping;
    grassTop.repeat.set(1000, 1000); // 1 tile per meter
    
    const grassMaterials = [
        new THREE.MeshStandardMaterial({ map: grassSide }),
        new THREE.MeshStandardMaterial({ map: grassSide }),
        new THREE.MeshStandardMaterial({ map: grassTop }),
        new THREE.MeshStandardMaterial({ map: grassSide }),
        new THREE.MeshStandardMaterial({ map: grassSide }),
        new THREE.MeshStandardMaterial({ map: grassSide })
    ];
    // Flat baseplate
    const baseplate = new THREE.Mesh(new THREE.BoxGeometry(1000, 2, 1000), grassMaterials);
    baseplate.position.y = -1; // Surface at y=0
    scene.add(baseplate);

    // --- Wooden Blocks (1x1x1 meters) ---
    const woodMaterials = [
        new THREE.MeshStandardMaterial({ map: woodSide }), 
        new THREE.MeshStandardMaterial({ map: woodSide }), 
        new THREE.MeshStandardMaterial({ map: woodTop }),  
        new THREE.MeshStandardMaterial({ map: woodTop }),  
        new THREE.MeshStandardMaterial({ map: woodSide }), 
        new THREE.MeshStandardMaterial({ map: woodSide })
    ];

    const blockGeo = new THREE.BoxGeometry(1, 1, 1);
    for(let i = 0; i < 100; i++) {
        const block = new THREE.Mesh(blockGeo, woodMaterials);
        // Randomly scatter within 50 meters of center
        block.position.x = Math.floor((Math.random() - 0.5) * 60);
        block.position.z = Math.floor((Math.random() - 0.5) * 60);
        block.position.y = 0.5; // Half of 1m height
        scene.add(block);
    }

    // --- Movement Logic ---
    const controls = new PointerLockControls(camera, document.body);
    document.addEventListener('click', () => controls.lock());

    let velocity = new THREE.Vector3();
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let canJump = false;

    // Start in the air
    camera.position.set(0, 10, 5); 

    const onKeyDown = (e) => {
        switch (e.code) {
            case 'KeyW': moveForward = true; break;
            case 'KeyA': moveLeft = true; break;
            case 'KeyS': moveBackward = true; break;
            case 'KeyD': moveRight = true; break;
            case 'Space': if (canJump) { velocity.y = 10; canJump = false; } break;
        }
    };
    const onKeyUp = (e) => {
        switch (e.code) {
            case 'KeyW': moveForward = false; break;
            case 'KeyA': moveLeft = false; break;
            case 'KeyS': moveBackward = false; break;
            case 'KeyD': moveRight = false; break;
        }
    };
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    // --- Game Loop ---
    let prevTime = performance.now();
    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now();
        const delta = Math.min((time - prevTime) / 1000, 0.1);

        if (controls.isLocked) {
            // Friction/Damping
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= 25.0 * delta; // Gravity

            const speed = 80.0;
            if (moveForward) velocity.z -= speed * delta;
            if (moveBackward) velocity.z += speed * delta;
            
            // Fixed Left/Right Inversion here:
            if (moveLeft) velocity.x -= speed * delta;
            if (moveRight) velocity.x += speed * delta;

            // Apply movement
            controls.moveRight(velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
            camera.position.y += velocity.y * delta;

            // Ground Collision (1.62m is Minecraft eye level)
            if (camera.position.y < 1.62) {
                velocity.y = 0;
                camera.position.y = 1.62;
                canJump = true;
            }
        }
        renderer.render(scene, camera);
        prevTime = time;
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
