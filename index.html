<!DOCTYPE html>
<html>
<head>
    <title>Minecraft - Infinite World & Depth</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: sans-serif; width: 100vw; height: 100vh; }
        canvas { display: block; width: 100%; height: 100%; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        #crosshair::before, #crosshair::after {
            content: ""; position: absolute; background: white; mix-blend-mode: difference;
        }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }

        #hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; line-height: 0; z-index: 20;
        }

        .slot {
            width: 50px; height: 50px; background-image: url('slot.jpg');
            background-size: 100% 100%; image-rendering: pixelated; position: relative;
        }

        .slot.active::after {
            content: ""; position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px;
            background-image: url('outline.jpg'); background-size: 100% 100%;
            image-rendering: pixelated; z-index: 10; pointer-events: none;
        }

        .item-icon {
            width: 32px; height: 32px; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); background-size: cover; image-rendering: pixelated;
        }

        .count {
            position: absolute; bottom: 4px; right: 4px; color: white;
            font-size: 14px; text-shadow: 2px 2px 0px #000; font-weight: bold;
        }

        #hand-container {
            position: absolute; bottom: 0; right: 10%; width: 300px; height: 300px;
            pointer-events: none; z-index: 25; overflow: hidden;
        }
        #steve-hand {
            width: 100%; height: 100%; background-image: url('steve-hand.png');
            background-size: contain; background-repeat: no-repeat; background-position: bottom right;
            image-rendering: pixelated; transform-origin: bottom right;
            transition: transform 0.1s;
        }
        .swing { transform: rotate(-20deg) translateY(20px) translateX(-20px); }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="hand-container"><div id="steve-hand"></div></div>
    
    <div id="hotbar">
        <div class="slot active" id="slot0"><div class="item-icon"></div><span class="count"></span></div>
        <div class="slot" id="slot1"><div class="item-icon"></div><span class="count"></span></div>
        <div class="slot" id="slot2"><div class="item-icon"></div><span class="count"></span></div>
        <div class="slot" id="slot3"><div class="item-icon"></div><span class="count"></span></div>
        <div class="slot" id="slot4"><div class="item-icon"></div><span class="count"></span></div>
        <div class="slot" id="slot5"><div class="item-icon"></div><span class="count"></span></div>
    </div>

    <canvas id="canvas"></canvas>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
    import { PointerLockControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/PointerLockControls.js';

    const CHUNK_SIZE = 8;
    const RENDER_DISTANCE = 3;
    const MAX_DEPTH = -200;
    let currentDeepestLayer = -10;
    let selectedSlot = 0;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const sun = new THREE.DirectionalLight(0xffffff, 0.8);
    sun.position.set(20, 50, 10);
    scene.add(sun);

    const loader = new THREE.TextureLoader();
    const load = (f) => { let t = loader.load(f); t.magFilter = t.minFilter = THREE.NearestFilter; return t; };

    const textures = {
        grass: { top: load('grass-top.jpg'), side: load('grass-side.jpg'), bottom: load('bottom.jpg'), icon: 'grass-side.jpg' },
        dirt: { all: load('bottom.jpg'), icon: 'bottom.jpg' },
        stone: { all: load('stone.jpg'), icon: 'stone.jpg' },
        deepslate: { all: load('stone.jpg'), icon: 'stone.jpg' }, 
        bedrock: { all: load('stone.jpg'), icon: 'stone.jpg' },
        wood: { side: load('wood.jpg'), top: load('woodtop.jpg'), icon: 'wood.jpg' },
        leaf: { all: load('leaf.jpg'), icon: 'leaf.jpg' }
    };

    const mats = {
        grass: [new THREE.MeshStandardMaterial({map: textures.grass.side}), new THREE.MeshStandardMaterial({map: textures.grass.side}), new THREE.MeshStandardMaterial({map: textures.grass.top}), new THREE.MeshStandardMaterial({map: textures.grass.bottom}), new THREE.MeshStandardMaterial({map: textures.grass.side}), new THREE.MeshStandardMaterial({map: textures.grass.side})],
        dirt: new THREE.MeshStandardMaterial({map: textures.dirt.all}),
        stone: new THREE.MeshStandardMaterial({map: textures.stone.all}),
        deepslate: new THREE.MeshStandardMaterial({map: textures.deepslate.all, color: 0x444444}),
        bedrock: new THREE.MeshStandardMaterial({map: textures.bedrock.all, color: 0x111111}),
        wood: [new THREE.MeshStandardMaterial({map: textures.wood.side}), new THREE.MeshStandardMaterial({map: textures.wood.side}), new THREE.MeshStandardMaterial({map: textures.wood.top}), new THREE.MeshStandardMaterial({map: textures.wood.top}), new THREE.MeshStandardMaterial({map: textures.wood.side}), new THREE.MeshStandardMaterial({map: textures.wood.side})],
        leaf: new THREE.MeshStandardMaterial({map: textures.leaf.all, transparent: true, alphaTest: 0.5})
    };

    const inventory = Array(6).fill(null);
    const MAX_STACK = 64;

    function addToInventory(type) {
        if(type === 'bedrock') return;
        let slotIndex = inventory.findIndex(item => item && item.type === type && item.count < MAX_STACK);
        if (slotIndex === -1) slotIndex = inventory.findIndex(item => item === null);
        if (slotIndex !== -1) {
            if (inventory[slotIndex]) inventory[slotIndex].count++;
            else inventory[slotIndex] = { type: type, count: 1 };
            updateUI();
        }
    }

    function updateUI() {
        inventory.forEach((item, i) => {
            const slot = document.getElementById(`slot${i}`);
            const icon = slot.querySelector('.item-icon');
            const count = slot.querySelector('.count');
            if (item) {
                icon.style.backgroundImage = `url(${textures[item.type].icon})`;
                count.innerText = item.count;
            } else {
                icon.style.backgroundImage = 'none';
                count.innerText = '';
            }
        });
    }

    let blocks = []; 
    const chunks = new Map();
    const blockGeo = new THREE.BoxGeometry(1, 1, 1);
    const selectionOutline = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(1.02, 1.02, 1.02)), new THREE.LineBasicMaterial({ color: 0x000000 }));
    scene.add(selectionOutline);

    function createBlock(type, x, y, z, parentGroup) {
        const mesh = new THREE.Mesh(blockGeo, mats[type]);
        mesh.position.set(x, y, z);
        mesh.userData.type = type;
        parentGroup.add(mesh);
        blocks.push(mesh);
        return mesh;
    }

    function createTree(x, z, group) {
        const height = 4 + Math.floor(Math.random() * 2);
        for (let y = 1; y <= height; y++) createBlock('wood', x, y, z, group);
        for (let ly = -2; ly <= 2; ly++) {
            let radius = ly > 0 ? (ly === 2 ? 0 : 1) : 2;
            for (let lx = -radius; lx <= radius; lx++) {
                for (let lz = -radius; lz <= radius; lz++) {
                    if (lx === 0 && lz === 0 && ly < 1) continue;
                    createBlock('leaf', x + lx, height + ly, z + lz, group);
                }
            }
        }
    }

    function generateLayers(cx, cz, group, startY, endY) {
        for (let x = 0; x < CHUNK_SIZE; x++) {
            for (let z = 0; z < CHUNK_SIZE; z++) {
                const px = cx * CHUNK_SIZE + x;
                const pz = cz * CHUNK_SIZE + z;
                for (let y = startY; y >= endY; y--) {
                    if (y < MAX_DEPTH) continue;
                    let type = 'stone';
                    if (y === 0) {
                        type = 'grass';
                        // Tree chance only at surface
                        const treeChance = Math.sin(px * 12.9898 + pz * 78.233) * 43758.5453;
                        if ((treeChance - Math.floor(treeChance)) > 0.985) createTree(px, pz, group);
                    }
                    else if (y > -4) type = 'dirt';
                    else if (y <= -50) type = 'deepslate';
                    if (y === MAX_DEPTH) type = 'bedrock';
                    createBlock(type, px, y, pz, group);
                }
            }
        }
    }

    function createChunk(cx, cz) {
        const group = new THREE.Group();
        generateLayers(cx, cz, group, 0, currentDeepestLayer);
        scene.add(group);
        return group;
    }

    function updateChunks() {
        const curCX = Math.floor(camera.position.x / CHUNK_SIZE);
        const curCZ = Math.floor(camera.position.z / CHUNK_SIZE);
        
        if (camera.position.y < currentDeepestLayer + 10 && currentDeepestLayer > MAX_DEPTH) {
            const nextDepth = Math.max(MAX_DEPTH, currentDeepestLayer - 4);
            chunks.forEach((group, key) => {
                const [cx, cz] = key.split(',').map(Number);
                generateLayers(cx, cz, group, currentDeepestLayer - 1, nextDepth);
            });
            currentDeepestLayer = nextDepth;
        }

        for (let x = curCX - RENDER_DISTANCE; x <= curCX + RENDER_DISTANCE; x++) {
            for (let z = curCZ - RENDER_DISTANCE; z <= curCZ + RENDER_DISTANCE; z++) {
                const key = `${x},${z}`;
                if (!chunks.has(key)) chunks.set(key, createChunk(x, z));
            }
        }
    }

    const controls = new PointerLockControls(camera, document.body);
    const raycaster = new THREE.Raycaster();
    const hand = document.getElementById('steve-hand');

    document.addEventListener('mousedown', (e) => {
        if (!controls.isLocked) return controls.lock();
        hand.classList.add('swing');
        setTimeout(() => hand.classList.remove('swing'), 100);

        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(blocks, false);
        if (intersects.length > 0 && intersects[0].distance < 5) {
            const intersect = intersects[0];
            if (e.button === 0) {
                if(intersect.object.userData.type !== 'bedrock') {
                    addToInventory(intersect.object.userData.type);
                    intersect.object.parent.remove(intersect.object);
                    blocks.splice(blocks.indexOf(intersect.object), 1);
                }
            } else if (e.button === 2) {
                const item = inventory[selectedSlot];
                if (item && item.count > 0) {
                    const pos = intersect.object.position.clone().add(intersect.face.normal);
                    createBlock(item.type, pos.x, pos.y, pos.z, intersect.object.parent);
                    item.count--;
                    if (item.count <= 0) inventory[selectedSlot] = null;
                    updateUI();
                }
            }
        }
    });

    document.addEventListener('contextmenu', e => e.preventDefault());

    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
    let velocity = new THREE.Vector3();

    document.addEventListener('keydown', (e) => {
        if (e.code === 'KeyW') moveForward = true;
        if (e.code === 'KeyS') moveBackward = true;
        if (e.code === 'KeyA') moveLeft = true;
        if (e.code === 'KeyD') moveRight = true;
        if (e.code === 'Space' && canJump) { velocity.y = 8; canJump = false; }
        if (e.key >= 1 && e.key <= 6) {
            document.getElementById(`slot${selectedSlot}`).classList.remove('active');
            selectedSlot = e.key - 1;
            document.getElementById(`slot${selectedSlot}`).classList.add('active');
        }
    });
    document.addEventListener('keyup', (e) => {
        if (e.code === 'KeyW') moveForward = false;
        if (e.code === 'KeyS') moveBackward = false;
        if (e.code === 'KeyA') moveLeft = false;
        if (e.code === 'KeyD') moveRight = false;
    });

    camera.position.set(4, 2, 4);
    let prevTime = performance.now();

    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now();
        const delta = Math.min((time - prevTime) / 1000, 0.1);

        if (controls.isLocked) {
            const oldPos = camera.position.clone();

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= 25.0 * delta; 

            if (moveForward) velocity.z -= 60.0 * delta;
            if (moveBackward) velocity.z += 60.0 * delta;
            if (moveLeft) velocity.x -= 60.0 * delta;
            if (moveRight) velocity.x += 60.0 * delta;

            controls.moveRight(velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
            
            // --- HORIZONTAL COLLISION CHECK (The 2-block gap fix) ---
            // Check if moving caused us to enter a block at chest/head height
            const checkRays = [
                new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0),
                new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)
            ];
            let collided = false;
            for (let rayDir of checkRays) {
                // Ray from feet and ray from head
                const rayFeet = new THREE.Raycaster(camera.position.clone().add(new THREE.Vector3(0,-1.5,0)), rayDir, 0, 0.4);
                const rayHead = new THREE.Raycaster(camera.position, rayDir, 0, 0.4);
                if (rayFeet.intersectObjects(blocks).length > 0 || rayHead.intersectObjects(blocks).length > 0) {
                    collided = true;
                    break;
                }
            }
            if (collided) {
                camera.position.x = oldPos.x;
                camera.position.z = oldPos.z;
            }

            camera.position.y += velocity.y * delta;

            // --- VERTICAL COLLISION ---
            const playerRay = new THREE.Raycaster(camera.position, new THREE.Vector3(0, -1, 0), 0, 1.7);
            const intersections = playerRay.intersectObjects(blocks);
            
            if (intersections.length > 0) {
                const dist = intersections[0].distance;
                if (dist < 1.7) {
                    camera.position.y += (1.7 - dist);
                    velocity.y = 0;
                    canJump = true;
                }
            } else { canJump = false; }

            updateChunks();

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(blocks, false);
            if (intersects.length > 0 && intersects[0].distance < 5) {
                selectionOutline.position.copy(intersects[0].object.position);
                selectionOutline.visible = true;
            } else { selectionOutline.visible = false; }
        }

        renderer.render(scene, camera);
        prevTime = time;
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    updateChunks();
    animate();
</script>
</body>
</html>
