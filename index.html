<!DOCTYPE html>
<html>
<head>
    <title>Minecraft - Infinite World</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: sans-serif; width: 100vw; height: 100vh; }
        canvas { display: block; width: 100%; height: 100%; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        #crosshair::before, #crosshair::after {
            content: ""; position: absolute; background: white; mix-blend-mode: difference;
        }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }

        #hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 4px; padding: 4px; background: rgba(0,0,0,0.5);
            border: 2px solid #333; z-index: 20;
        }

        .slot {
            width: 50px; height: 50px; background: rgba(0, 0, 0, 0.3);
            border: 2px solid #555; position: relative; box-sizing: border-box;
            background-size: cover; image-rendering: pixelated;
        }

        .slot.active { border: 4px solid white; background-color: rgba(255, 255, 255, 0.2); }

        .count {
            position: absolute; bottom: 2px; right: 2px; color: white;
            font-size: 12px; text-shadow: 1px 1px 2px black; font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="hotbar">
        <div class="slot active" id="slot1"><span class="count"></span></div>
        <div class="slot" id="slot2"><span class="count"></span></div>
        <div class="slot" id="slot3"><span class="count"></span></div>
        <div class="slot" id="slot4"><span class="count"></span></div>
        <div class="slot" id="slot5"><span class="count"></span></div>
        <div class="slot" id="slot6"><span class="count"></span></div>
    </div>

    <canvas id="canvas"></canvas>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
    import { PointerLockControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/PointerLockControls.js';

    const CHUNK_SIZE = 16;
    const RENDER_DISTANCE = 2; 

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 10, (RENDER_DISTANCE * CHUNK_SIZE) + 10);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const sun = new THREE.DirectionalLight(0xffffff, 0.8);
    sun.position.set(20, 50, 10);
    scene.add(sun);

    const loader = new THREE.TextureLoader();
    const load = (file) => {
        const t = loader.load(file);
        t.magFilter = THREE.NearestFilter;
        t.minFilter = THREE.NearestFilter;
        return t;
    };

    const grassTop = load('grass-top.jpg'), grassSide = load('grass-side.jpg'), dirtTex = load('bottom.jpg');
    const woodSide = load('wood.jpg'), woodTop = load('woodtop.jpg'), leafTex = load('leaf.jpg');

    const grassMats = [
        new THREE.MeshStandardMaterial({ map: grassSide, name: 'grass' }), new THREE.MeshStandardMaterial({ map: grassSide }),
        new THREE.MeshStandardMaterial({ map: grassTop }), new THREE.MeshStandardMaterial({ map: dirtTex }),
        new THREE.MeshStandardMaterial({ map: grassSide }), new THREE.MeshStandardMaterial({ map: grassSide })
    ];
    const dirtMat = new THREE.MeshStandardMaterial({ map: dirtTex, name: 'dirt' });
    const woodMats = [
        new THREE.MeshStandardMaterial({ map: woodSide, name: 'wood' }), new THREE.MeshStandardMaterial({ map: woodSide }),
        new THREE.MeshStandardMaterial({ map: woodTop }), new THREE.MeshStandardMaterial({ map: woodTop }),
        new THREE.MeshStandardMaterial({ map: woodSide }), new THREE.MeshStandardMaterial({ map: woodSide })
    ];
    const leafMat = new THREE.MeshStandardMaterial({ map: leafTex, transparent: true, alphaTest: 0.5, name: 'leaf' });

    // --- INVENTORY SYSTEM ---
    const inventory = [null, null, null, null, null, null];
    const iconMap = {
        'grass': 'grass-side.jpg',
        'dirt': 'bottom.jpg',
        'wood': 'wood.jpg',
        'leaf': 'leaf.jpg'
    };

    function addToInventory(type) {
        // Try to find existing stack
        let slotIndex = inventory.findIndex(item => item && item.type === type);
        
        if (slotIndex === -1) {
            // Find first empty slot
            slotIndex = inventory.findIndex(item => item === null);
        }

        if (slotIndex !== -1) {
            if (inventory[slotIndex]) {
                inventory[slotIndex].count++;
            } else {
                inventory[slotIndex] = { type: type, count: 1 };
            }
            updateUI();
        }
    }

    function updateUI() {
        inventory.forEach((item, i) => {
            const slot = document.getElementById(`slot${i+1}`);
            const countEl = slot.querySelector('.count');
            if (item) {
                slot.style.backgroundImage = `url(${iconMap[item.type]})`;
                countEl.innerText = item.count;
            } else {
                slot.style.backgroundImage = 'none';
                countEl.innerText = '';
            }
        });
    }

    let blocks = []; 
    const chunks = new Map();
    const blockGeo = new THREE.BoxGeometry(1, 1, 1);

    const selectionOutline = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.BoxGeometry(1.02, 1.02, 1.02)), 
        new THREE.LineBasicMaterial({ color: 0x000000 })
    );
    scene.add(selectionOutline);

    function seededRandom(x, z) {
        const val = Math.sin(x * 12.9898 + z * 78.233) * 43758.5453123;
        return val - Math.floor(val);
    }

    function createTree(x, z, group) {
        const trunkHeight = 4 + Math.floor(seededRandom(x, z) * 2);
        for (let y = 1; y <= trunkHeight; y++) {
            const log = new THREE.Mesh(blockGeo, woodMats);
            log.position.set(x, y, z);
            log.userData.type = 'wood';
            group.add(log);
            blocks.push(log);
        }
        for (let ly = -2; ly <= 2; ly++) {
            let radius = (ly > 0) ? 1 : 2;
            for (let lx = -radius; lx <= radius; lx++) {
                for (let lz = -radius; lz <= radius; lz++) {
                    if (ly === 2 && (Math.abs(lx) + Math.abs(lz) > 1)) continue;
                    if (lx === 0 && lz === 0 && ly < 0) continue;
                    const leaf = new THREE.Mesh(blockGeo, leafMat);
                    leaf.position.set(x + lx, trunkHeight + ly, z + lz);
                    leaf.userData.type = 'leaf';
                    group.add(leaf);
                    blocks.push(leaf);
                }
            }
        }
    }

    function createChunk(cx, cz) {
        const group = new THREE.Group();
        for (let x = 0; x < CHUNK_SIZE; x++) {
            for (let z = 0; z < CHUNK_SIZE; z++) {
                const px = cx * CHUNK_SIZE + x;
                const pz = cz * CHUNK_SIZE + z;
                
                const grass = new THREE.Mesh(blockGeo, grassMats);
                grass.position.set(px, 0, pz);
                grass.userData.type = 'grass';
                group.add(grass);
                blocks.push(grass);

                const dirt = new THREE.Mesh(blockGeo, dirtMat);
                dirt.position.set(px, -1, pz);
                dirt.userData.type = 'dirt';
                group.add(dirt);
                blocks.push(dirt);

                if (seededRandom(px, pz) > 0.985) createTree(px, pz, group);
            }
        }
        scene.add(group);
        return group;
    }

    function updateChunks() {
        const curCX = Math.floor(camera.position.x / CHUNK_SIZE);
        const curCZ = Math.floor(camera.position.z / CHUNK_SIZE);

        for (let x = curCX - RENDER_DISTANCE; x <= curCX + RENDER_DISTANCE; x++) {
            for (let z = curCZ - RENDER_DISTANCE; z <= curCZ + RENDER_DISTANCE; z++) {
                const key = `${x},${z}`;
                if (!chunks.has(key)) chunks.set(key, createChunk(x, z));
            }
        }

        for (const [key, group] of chunks) {
            const [cx, cz] = key.split(',').map(Number);
            if (Math.abs(cx - curCX) > RENDER_DISTANCE + 1 || Math.abs(cz - curCZ) > RENDER_DISTANCE + 1) {
                scene.remove(group);
                const idsToRemove = new Set(group.children);
                blocks = blocks.filter(b => !idsToRemove.has(b));
                chunks.delete(key);
            }
        }
    }

    const controls = new PointerLockControls(camera, document.body);
    const raycaster = new THREE.Raycaster();

    document.addEventListener('mousedown', (e) => {
        if (!controls.isLocked) {
            controls.lock();
            document.documentElement.requestFullscreen().catch(() => {});
        } else if (e.button === 0) {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(blocks, false);
            if (intersects.length > 0 && intersects[0].distance < 6) {
                const block = intersects[0].object;
                
                // Add to inventory based on saved userData type
                if (block.userData.type) addToInventory(block.userData.type);
                
                if (block.parent) block.parent.remove(block);
                const index = blocks.indexOf(block);
                if (index > -1) blocks.splice(index, 1);
            }
        }
    });

    let velocity = new THREE.Vector3();
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let canJump = false;
    camera.position.set(8, 3, 8);

    const onKeyDown = (e) => {
        switch (e.code) {
            case 'KeyW': moveForward = true; break;
            case 'KeyA': moveLeft = true; break;
            case 'KeyS': moveBackward = true; break;
            case 'KeyD': moveRight = true; break;
            case 'Space': if (canJump) { velocity.y = 9; canJump = false; } break;
            case 'Digit1': case 'Digit2': case 'Digit3': case 'Digit4': case 'Digit5': case 'Digit6':
                document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
                document.getElementById('slot' + e.key.replace('Digit', '')).classList.add('active');
                break;
        }
    };
    const onKeyUp = (e) => {
        switch (e.code) {
            case 'KeyW': moveForward = false; break;
            case 'KeyA': moveLeft = false; break;
            case 'KeyS': moveBackward = false; break;
            case 'KeyD': moveRight = false; break;
        }
    };
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    let prevTime = performance.now();
    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now();
        const delta = Math.min((time - prevTime) / 1000, 0.1);

        if (controls.isLocked) {
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= 24.0 * delta; 
            const speed = 75.0;
            if (moveForward) velocity.z -= speed * delta;
            if (moveBackward) velocity.z += speed * delta;
            if (moveLeft) velocity.x -= speed * delta;
            if (moveRight) velocity.x += speed * delta;

            controls.moveRight(velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
            camera.position.y += velocity.y * delta;

            if (camera.position.y < 2.1) {
                velocity.y = 0; camera.position.y = 2.1; canJump = true;
            }

            if (Math.round(time) % 20 === 0) updateChunks();

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(blocks, false);
            if (intersects.length > 0 && intersects[0].distance < 6) {
                selectionOutline.position.copy(intersects[0].object.position);
                selectionOutline.visible = true;
            } else {
                selectionOutline.visible = false;
            }
        }
        renderer.render(scene, camera);
        prevTime = time;
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    updateChunks();
    animate();
</script>
</body>
</html>
